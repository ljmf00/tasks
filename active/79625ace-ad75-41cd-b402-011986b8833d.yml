summary: Add post about classes in betterC
notes: "# Zettelkasten #1: Did you know that you can use classes in D as better C?\n\nYes, you read correctly, you can actually use classes in D with `-betterC`.\n\n## Problem involved\n\nThe main problem with having normal classes in D as better C is the dependency\nof runtime hooks and runtime type information from the D runtime library. Since\nbetterC has some limitations, including forbidden usage of runtime type\ninformation, users are usually stuck with features from D that doesn't use the\nruntime. Although, on the other hand, betterC doesn't limit the usage of C and\nC++ linkage, since they are not dependent of any runtime library.\n\n## What is the tricky part?\n\nThere is a tricky part involved in instanciating `extern(C++)` classes however.\nAt the time of this post, with the latest version of the compiler, is not\neasily possible to fetch the init memory block of a class without:\n\n1. Rely on the `TypeInfo` (use `typeid(ClassFoo).initializer`)\n2. Create a dummy `scope` instance of the class and copy the memory to a newly\n   allocated buffer.\n\nBoth of this options have drawbacks and the first one is only possible on\n`betterC` if we manually create and remove some symbols.\n\nThe second option is also limitative, since the user are not able to use the\nnormal class destructor. If you don't use any special destructor, you can\neasily fetch that class initializer with something like this:\n\n```d\nstatic auto initializer()\n{\n    alias T = typeof(this);\n    void[__traits(classInstanceSize, T)] t = void;\n    scope T s = new T;\n    t[] = (cast(void*)s)[0 .. t.length];\n    return t;\n}\n```\n\nYou can also circumvent this issue by using a custom destructor, although you\nwon't benefit from the\n[RAII](https://ipfs.io/ipfs/bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/wiki/Resource_Acquisition_Is_Initialization.html)\nidiom.\n\n## A reasonable solution\n\nFortunately, LDC has a compiler trait `__traits(initSymbol)`, which will be\nsoon described by the D specification and\n[implemented](https://github.com/dlang/dmd/pull/13298) by the reference\ncompiler (DMD) that can do exactly that, fetch the initializer of a class type.\n\nYou just need to create custom allocate and destroy function templates:\n\n```d\nT alloc(T, Args...)(auto ref Args args)\n{\n\tenum tsize = typeof(T.__classinit()).sizeof;\n\timport core.stdc.stdlib : malloc;\n\tauto t = cast(T)malloc(tsize);\n\timport core.stdc.string : memcpy;\n\tmemcpy(cast(void*)t, __traits(initSymbol, T).ptr, tsize);\n\tt.__ctor(args);\n\n\treturn t;\n}\n\nvoid destroy(T)(ref T t)\n{\n\timport core.stdc.stdlib : free;\n\tt.__ctor();\n\tfree(cast(void*)t);\n\tt = null;\n}\n```\n\nWith those two functions you can now just allocate a new class instance:\n\n```d\nextern(C++) class Foo\n{\n    this(int a, float b)\n    {\n        this.a = a * 2;\n        this.b = b;\n    }\n\n    int a;\n    float b;\n}\n\nextern(C) int main()\n{\n    Foo foo = alloc!Foo(2, 2.0f);\n\n    int a = foo.a; // 4\n    float b = foo.b; // 2.0\n\n    return 0;\n}\n```\n"
tags:
- blog
project: personal
priority: P2
delegatedto: ""
subtasks: []
dependencies: []
created: 2021-11-15T00:13:09.515700945Z
resolved: 0001-01-01T00:00:00Z
due: 0001-01-01T00:00:00Z
